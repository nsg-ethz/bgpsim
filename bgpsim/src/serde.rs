// BgpSim: BGP Network Simulator written in Rust
// Copyright 2022-2024 Tibor Schneider <sctibor@ethz.ch>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! This module contains functions to save the network to a file, and restore it from a file.

use std::collections::{BTreeSet, HashMap};

#[cfg(feature = "topology_zoo")]
use geoutils::Location;
use itertools::Itertools;
#[cfg(feature = "topology_zoo")]
use mapproj::{cylindrical::mer::Mer, LonLat, Projection};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::HashSet;

#[cfg(feature = "topology_zoo")]
use crate::topology_zoo::TopologyZoo;
use crate::{
    config::{ConfigExpr, ConfigModifier, NetworkConfig},
    event::{BasicEventQueue, EventQueue},
    network::Network,
    ospf::{LocalOspf, OspfImpl},
    policies::{FwPolicy, Policy, PolicyError},
    types::{
        AsId, IntoIpv4Prefix, Ipv4Prefix, NetworkDeviceRef, NetworkError, Prefix, PrefixMap,
        RouterId,
    },
};

const JSON_FIELD_NAME_NETWORK: &str = "net";
const JSON_FIELD_NAME_CONFIG: &str = "config_nodes_routes";

type ExportRoutes<P> = (RouterId, P, Vec<AsId>, Option<u32>, BTreeSet<u32>);
type ExportConfig<P> = Vec<ConfigExpr<P>>;
type ExportRouters = Vec<(RouterId, String, Option<AsId>)>;
type ExportLinks = Vec<(RouterId, RouterId)>;
type ExportTuple<P> = (
    ExportConfig<P>,
    ExportRouters,
    ExportLinks,
    Vec<ExportRoutes<P>>,
);

impl<P, Q, Ospf> Network<P, Q, Ospf>
where
    P: Prefix,
    Q: EventQueue<P> + Serialize,
    Ospf: OspfImpl,
{
    /// Create a json string from the network. This string will contain both the actual network
    /// state and the configuration. In case the network state can no longer be deserialized, the
    /// configuration can be used to restore the network to a similar state.
    pub fn as_json_str(&self) -> String {
        serde_json::to_string(&json!({
            JSON_FIELD_NAME_NETWORK: serde_json::to_value(self).unwrap(),
            JSON_FIELD_NAME_CONFIG: self.as_config_json_value(),
        }))
        .unwrap()
    }

    /// Create a json string from the network. This string will only contain the configuration, not
    /// the serialized network itself. Thus, this string is significantly smaller than the string
    /// generated by `Network::as_json_str`.
    pub fn as_json_str_compact(&self) -> String {
        serde_json::to_string(&json!({
            JSON_FIELD_NAME_CONFIG: self.as_config_json_value()
        }))
        .unwrap()
    }

    /// Create a json value containing the configuration.
    fn as_config_json_value(&self) -> serde_json::Value {
        serde_json::to_value(self.as_config_node_routes()).unwrap()
    }
}

impl<P, Q, Ospf> Network<P, Q, Ospf>
where
    P: Prefix,
    Q: EventQueue<P>,
    Ospf: OspfImpl,
{
    /// Create a json value containing the configuration.
    fn as_config_node_routes(&self) -> ExportTuple<P> {
        let config = Vec::from_iter(self.get_config().unwrap().iter().cloned());
        let mut nodes: Vec<(RouterId, String, Option<AsId>)> = self
            .devices()
            .map(|r| match r {
                NetworkDeviceRef::InternalRouter(r) => (r.router_id(), r.name().to_string(), None),
                NetworkDeviceRef::ExternalRouter(r) => {
                    (r.router_id(), r.name().to_string(), Some(r.as_id()))
                }
            })
            .collect();
        nodes.sort_by_key(|(r, _, _)| *r);

        let links: Vec<(RouterId, RouterId)> = self
            .ospf
            .edges()
            .map(|e| (e.src(), e.dst()))
            .map(|(a, b)| if a < b { (a, b) } else { (b, a) })
            .unique()
            .collect();

        let routes: Vec<ExportRoutes<P>> = self
            .external_routers()
            .flat_map(|r| {
                let id = r.router_id();
                r.get_advertised_routes().values().map(move |route| {
                    (
                        id,
                        route.prefix,
                        route.as_path.clone(),
                        route.med,
                        route.community.clone(),
                    )
                })
            })
            .collect();
        (config, nodes, links, routes)
    }
}

/// A data structure to generate json files for importing into [bgpsim.github.io](bgpsim.github.io).
#[derive(Debug, Serialize)]
#[allow(clippy::type_complexity)]
pub struct WebExporter {
    net: Option<Network<Ipv4Prefix, BasicEventQueue<Ipv4Prefix>, LocalOspf>>,
    config_node_routes: ExportTuple<Ipv4Prefix>,
    pos: Option<HashMap<RouterId, Point>>,
    spec:
        Option<HashMap<RouterId, Vec<(FwPolicy<Ipv4Prefix>, Result<(), PolicyError<Ipv4Prefix>>)>>>,
    fixed: Option<HashSet<RouterId>>,
    #[cfg(feature = "topology_zoo")]
    topology_zoo: Option<TopologyZoo>,
    #[serde(skip)]
    compact: bool,
}

impl WebExporter {
    /// Create a new, empty web exporter.
    pub fn new<P: Prefix, Q: EventQueue<P> + Clone, Ospf: OspfImpl>(
        net: &Network<P, Q, Ospf>,
    ) -> Self {
        // transform the queue into a basic event queue
        let mut net = net.clone();
        let mut queue: BasicEventQueue<Ipv4Prefix> = Default::default();
        while let Some(e) = net.queue.pop() {
            queue.0.push_back(e.into_ipv4_prefix())
        }
        // make OSPF local
        let net = net.into_global_ospf().unwrap().into_local_ospf().unwrap();

        // only now, swap the queue.
        let Ok(net) = net.into_ipv4_prefix(queue) else {
            unreachable!("Queue was emptied above")
        };

        // create the config
        let config_node_routes = net.as_config_node_routes();

        Self {
            net: Some(net),
            config_node_routes,
            pos: None,
            spec: None,
            fixed: None,
            #[cfg(feature = "topology_zoo")]
            topology_zoo: None,
            compact: false,
        }
    }

    /// Remove the serialized network from the json, only keeping the configuration, the topology,
    /// and the advertised routes.
    pub fn compact(mut self) -> Self {
        self.compact = true;
        self
    }

    /// Set the specification while exporting
    pub fn spec<P: Prefix>(mut self, spec: Vec<FwPolicy<P>>) -> Self {
        // first, get the forwarding state
        let Some(net) = self.net.as_ref() else {
            self.spec = Some(
                spec.into_iter()
                    .map(FwPolicy::into_ipv4_prefix)
                    .map(|s| (s.router().unwrap(), (s, Ok(()))))
                    .into_group_map(),
            );
            return self;
        };
        let mut fw_state = net.get_forwarding_state();
        // transform the spec into the required data format.
        self.spec = Some(
            spec.into_iter()
                .map(FwPolicy::into_ipv4_prefix)
                .map(|s| (s.router().unwrap(), (s.clone(), s.check(&mut fw_state))))
                .into_group_map(),
        );
        self
    }

    /// Set the topology zoo variant that was used to create this network. Any previously set
    /// positions will be overwritten.
    #[cfg(feature = "topology_zoo")]
    pub fn topology_zoo(mut self, topo: TopologyZoo) -> Self {
        // do nothing if `self.net` is None.
        let Some(net) = self.net.as_ref() else {
            return self;
        };

        // build the position
        fn rad(x: Location) -> LonLat {
            let mut lon = x.longitude();
            let mut lat = x.latitude();
            if lon < 0.0 {
                lon += 360.0;
            }
            lon = lon * std::f64::consts::PI / 180.0;
            lat = lat * std::f64::consts::PI / 180.0;
            LonLat::new(lon, lat)
        }

        let mut geo = topo.geo_location();
        geo.retain(|_, pos| pos.latitude() != 0.0 || pos.longitude() != 0.0);
        if geo.is_empty() {
            // nothing to do, we don't have any geo information available.
            return self;
        }
        let mut pos = HashMap::new();
        let mut fixed = HashSet::new();
        if !geo.is_empty() {
            let points = geo.values().collect_vec();
            let center = rad(Location::center(&points));
            let proj = Mer::new();
            for r in net.get_topology().node_indices() {
                let p = match geo.get(&r).map(|pos| rad(*pos)) {
                    Some(p) => {
                        fixed.insert(r);
                        p
                    }
                    None => {
                        let offset = r.index() as f64 / 100.0;
                        LonLat::new(center.lon() + offset, center.lat() + offset)
                    }
                };
                let xy = proj.proj_lonlat(&p).unwrap();
                pos.insert(
                    r,
                    Point {
                        x: xy.x(),
                        y: -xy.y(),
                    },
                );
            }
        }

        self.fixed = Some(fixed);
        self.topology_zoo = Some(topo);
        self.pos = Some(pos);
        self
    }

    /// Set the positions of each router. Any position that is not fixed will be automatically
    /// determined using the spring-layout when importing into the web-app. This function will
    /// modify the existing positions accordingly, overwriting existing positions while keeping the
    /// old ones.
    pub fn set_positions(mut self, pos: HashMap<RouterId, Point>) -> Self {
        self.fixed
            .get_or_insert(Default::default())
            .extend(pos.keys().copied());
        self.pos.get_or_insert(Default::default()).extend(pos);
        self
    }

    /// Create a json string representing the network.
    pub fn to_json(mut self) -> String {
        if self.compact {
            self.net = None;
        }

        serde_json::to_string(&self).unwrap()
    }
}

/// A point in 2 dimensional space, used to define the positioning of nodes.
#[derive(Debug, Serialize)]
pub struct Point {
    /// The x coordinate. The scaling is done automatically by the web-app.
    pub x: f64,
    /// The y coordinate. The scaling is done automatically by the web-app.
    pub y: f64,
}

impl<P, Q, Ospf> Network<P, Q, Ospf>
where
    P: Prefix,
    Q: EventQueue<P>,
    Ospf: OspfImpl,
    for<'a> Q: Deserialize<'a>,
{
    /// Read a json file containing the network and create the network. If the network cannot be
    /// deserialized directly, reconstruct it from the configuration that should also be part of the
    /// exported file.
    ///
    /// The `default_queue` function must return a queue in case the network cannot be deserialized
    /// directly, but it needs to be built up from the configuration. For instance, use
    /// `Default::default` for a queue `Q` like `BasicEventQueue` that implements `Default`.
    pub fn from_json_str<F>(s: &str, default_queue: F) -> Result<Self, NetworkError>
    where
        F: FnOnce() -> Q,
    {
        // first, try to deserialize the network. If that works, ignore the config
        let content: serde_json::Value = serde_json::from_str(s)?;
        if let Some(net) = content
            .get(JSON_FIELD_NAME_NETWORK)
            .and_then(|v| serde_json::from_value(v.clone()).ok())
        {
            Ok(net)
        } else {
            match content
                .get(JSON_FIELD_NAME_CONFIG)
                .and_then(|v| v.as_array())
            {
                Some(v) if v.len() == 4 => Self::from_config_nodes_routes(
                    v[0].clone(),
                    v[1].clone(),
                    v[2].clone(),
                    v[3].clone(),
                    default_queue,
                ),
                _ => Err(serde_json::from_str::<ConfigNodeRoutes>(s).unwrap_err())?,
            }
        }
    }
}

impl<P, Q, Ospf> Network<P, Q, Ospf>
where
    P: Prefix,
    Q: EventQueue<P>,
    Ospf: OspfImpl,
{
    /// Deserialize the json structure containing configuration, nodes and routes.
    fn from_config_nodes_routes<F>(
        config: serde_json::Value,
        nodes: serde_json::Value,
        links: serde_json::Value,
        routes: serde_json::Value,
        default_queue: F,
    ) -> Result<Self, NetworkError>
    where
        F: FnOnce() -> Q,
    {
        let config: Vec<ConfigExpr<P>> = serde_json::from_value(config)?;
        let nodes: Vec<(RouterId, String, Option<AsId>)> = serde_json::from_value(nodes)?;
        let links: Vec<(RouterId, RouterId)> = serde_json::from_value(links)?;
        let routes: Vec<ExportRoutes<P>> = serde_json::from_value(routes)?;
        let mut nodes_lut: HashMap<RouterId, RouterId> = HashMap::new();
        let mut net = Network::new(default_queue());
        // add all nodes and create the lut
        for (id, name, as_id) in nodes.into_iter() {
            let new_id = if let Some(as_id) = as_id {
                net.add_external_router(name, as_id)
            } else {
                net.add_router(name)
            };
            nodes_lut.insert(id, new_id);
        }
        // create the function to lookup nodes
        let node = |id: RouterId| {
            nodes_lut
                .get(&id)
                .copied()
                .ok_or(NetworkError::DeviceNotFound(id))
        };
        let links = links
            .into_iter()
            .map(|(a, b)| Ok::<_, NetworkError>((node(a)?, node(b)?)))
            .collect::<Result<Vec<_>, _>>()?;
        net.add_links_from(links)?;
        // apply all configurations

        for expr in config.iter() {
            let expr = match expr.clone() {
                ConfigExpr::IgpLinkWeight {
                    source,
                    target,
                    weight,
                } => ConfigExpr::IgpLinkWeight {
                    source: node(source)?,
                    target: node(target)?,
                    weight,
                },
                ConfigExpr::OspfArea {
                    source,
                    target,
                    area,
                } => ConfigExpr::OspfArea {
                    source: node(source)?,
                    target: node(target)?,
                    area,
                },
                ConfigExpr::BgpSession {
                    source,
                    target,
                    session_type,
                } => ConfigExpr::BgpSession {
                    source: node(source)?,
                    target: node(target)?,
                    session_type,
                },
                ConfigExpr::BgpRouteMap {
                    router,
                    neighbor,
                    direction,
                    map,
                } => ConfigExpr::BgpRouteMap {
                    router: node(router)?,
                    neighbor: node(neighbor)?,
                    direction,
                    map,
                },
                ConfigExpr::StaticRoute {
                    router,
                    prefix,
                    target,
                } => ConfigExpr::StaticRoute {
                    router: node(router)?,
                    prefix,
                    target,
                },
                ConfigExpr::LoadBalancing { router } => ConfigExpr::LoadBalancing {
                    router: node(router)?,
                },
            };
            net.apply_modifier(&ConfigModifier::Insert(expr))?;
        }
        for (src, prefix, as_path, med, community) in routes.into_iter() {
            net.advertise_external_route(src, prefix, as_path, med, community)?;
        }
        Ok(net)
    }
}

/// Dummy struct that allows us to create meaningful error messages
#[derive(Debug, Deserialize)]
struct ConfigNodeRoutes {
    #[allow(dead_code)]
    config_nodes_routes: (serde_json::Value, serde_json::Value, serde_json::Value),
}

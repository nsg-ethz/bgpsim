//! Module to record actions on the network and extract a trace of how the forwarding state changes
//! over time.

use std::collections::HashMap;

use crate::{
    event::FmtPriority,
    interactive::InteractiveNetwork,
    route_map::{RouteMap, RouteMapDirection},
    AsId, BgpSessionType, EventQueue, ForwardingState, LinkWeight, Network, NetworkError, Prefix,
    RouterId,
};

/// Extension trait that allows you to record events on the network.
pub trait RecordNetwork<Q> {
    /// Simulate a single action on the network and extract the record of the convergence
    /// process. This function will record the forwarding state of all prefixes in the network.
    ///
    /// The function pointer takes as input `NetworkRef`, a wrapper around a mutable reference to
    /// the network. This allows you to trigger only a single modification of the network which will
    /// destruct the mutable reference. This ensures that only a single event is triggered at once.
    ///
    /// This function will return either the trace and the initial forwarding state, or the network
    /// error generated by `f`.
    fn record<F>(&mut self, f: F) -> Result<ConvergenceRecording, NetworkError>
    where
        F: FnOnce(NetworkRef<Q>) -> Result<(), NetworkError>;

    /// Simulate the network (by running all enqueued events). During this, construct a
    /// `ConvergenceRecording` by recording every single change in the forwarding behavior of the
    /// network. This function takes `initial_fw_state` (before any event happened), and the
    /// `initial_trace`, that contains the difference from the initial forarding state to the state
    /// that is currently present.
    ///
    /// Consider the implementation of [`RecordNetwork::record`] for `Network` to see an example of
    /// how to use this function.
    fn record_prepared(
        &mut self,
        initial_fw_state: ForwardingState,
        initial_trace: HashMap<Prefix, ConvergenceTrace>,
    ) -> Result<ConvergenceRecording, NetworkError>;
}

impl<Q> RecordNetwork<Q> for Network<Q>
where
    Q: EventQueue,
    Q::Priority: FmtPriority + Default + Clone,
{
    fn record<F>(&mut self, f: F) -> Result<ConvergenceRecording, NetworkError>
    where
        F: FnOnce(NetworkRef<'_, Q>) -> Result<(), NetworkError>,
    {
        // set the queue to skip mode.
        let original_skip_value = self.skip_queue;
        self.skip_queue = true;

        // get the forwarding state before
        let fw_state_before = self.get_forwarding_state();

        // execute the function
        f(NetworkRef(self))?;

        // get the forwarding state difference and start generating the trace
        let fw_state_after = self.get_forwarding_state();
        let diff = fw_state_before.diff(&fw_state_after);

        let trace = diff
            .into_iter()
            .map(|(prefix, delta)| (prefix, vec![delta]))
            .collect::<HashMap<Prefix, ConvergenceTrace>>();

        // now, generate the recording using the intrinsic function
        let record = self.record_prepared(fw_state_before, trace)?;

        // reset the queue skip property
        self.skip_queue = original_skip_value;

        Ok(record)
    }

    fn record_prepared(
        &mut self,
        initial_fw_state: ForwardingState,
        mut trace: HashMap<Prefix, ConvergenceTrace>,
    ) -> Result<ConvergenceRecording, NetworkError> {
        while let Some((step, event)) = self.simulate_step()? {
            if step.changed() {
                if let Some(prefix) = step.prefix {
                    trace.entry(prefix).or_default().push(vec![(
                        event.router(),
                        step.old,
                        step.new,
                    )]);
                }
            }
        }
        Ok(ConvergenceRecording::new(initial_fw_state, trace))
    }
}

/// Record of an entire convergence process that captures the history of each change in the
/// forwarding state of the network. This is a record that allows the state to be moved forwards or
/// backwards in time. The recording can be changed on a per-prefix level.
#[derive(Debug, Clone, PartialEq)]
pub struct ConvergenceRecording {
    state: ForwardingState,
    trace: HashMap<Prefix, ConvergenceTrace>,
    pointers: HashMap<Prefix, usize>,
}

impl ConvergenceRecording {
    /// Create a Recofrding from a trace and an initial forwarding state
    pub fn new(
        initial_fw_state: ForwardingState,
        trace: HashMap<Prefix, ConvergenceTrace>,
    ) -> Self {
        let pointers: HashMap<Prefix, usize> = trace.keys().map(|p| (*p, 0)).collect();
        ConvergenceRecording {
            state: initial_fw_state,
            trace,
            pointers,
        }
    }

    /// Get a reference to the current forwarding state
    pub fn state(&mut self) -> &mut ForwardingState {
        &mut self.state
    }

    /// Get a reference of the convergence trace.
    pub fn trace(&self) -> &HashMap<Prefix, ConvergenceTrace> {
        &self.trace
    }

    /// Transform the recording into a trace.
    pub fn as_trace(self) -> HashMap<Prefix, ConvergenceTrace> {
        self.trace
    }

    /// Perform a single step for an individual prefix. If the forwarding state is already in the
    /// final state for the specifiied prefix, then this function will return `None`. Otherwise, it
    /// will return a slice containing all deltas that were applied during this function call.
    pub fn step(&mut self, prefix: Prefix) -> Option<&[FwDelta]> {
        let pointer = self.pointers.get_mut(&prefix)?;
        let trace = self.trace.get(&prefix)?;
        if *pointer >= trace.len() {
            // already out of bounds
            return None;
        }
        // apply the delta at the current position
        let deltas = trace.get(*pointer)?;
        for (router, _, new_nh) in deltas {
            self.state.update(*router, prefix, *new_nh);
        }

        // increment the pointer
        *pointer += 1;

        // return the applied deltas
        Some(deltas)
    }

    /// Undo a single step for an individual prefix. If the forwarding state is already in the
    /// initial state for the specifiied prefix, then this function will return `None`. Otherwise, it
    /// will return a slice containing all deltas that applied *in reverse direction* during this
    /// function call.
    pub fn back(&mut self, prefix: Prefix) -> Option<&[FwDelta]> {
        let pointer = self.pointers.get_mut(&prefix)?;
        let trace = self.trace.get(&prefix)?;
        if *pointer == 0 {
            // already out of bounds
            return None;
        }
        // decrement the pointer
        *pointer -= 1;
        // apply the delta at the current position
        let deltas = trace.get(*pointer)?;
        for (router, old_nh, _) in deltas {
            self.state.update(*router, prefix, *old_nh);
        }

        // return the applied deltas
        Some(deltas)
    }

    /// Get the position of the recording for the given prefix.
    pub fn pos(&self, prefix: Prefix) -> usize {
        self.pointers.get(&prefix).copied().unwrap_or_default()
    }

    /// Get the length of the recording for the given prefix
    #[allow(clippy::len_without_is_empty)]
    pub fn len(&self, prefix: Prefix) -> usize {
        self.trace.get(&prefix).map(|t| t.len()).unwrap_or_default()
    }

    /// Check if the recording is empty for the given prefix
    pub fn is_empty(&self, prefix: Prefix) -> bool {
        self.trace
            .get(&prefix)
            .map(|t| t.is_empty())
            .unwrap_or(true)
    }
}

/// This structure captures the essence of a trace, that is, the entire evolution of the forwarding
/// state during the convergence process. It does not capture the initial or the final state, but it
/// should be efficient to compare entries.
pub type ConvergenceTrace = Vec<Vec<FwDelta>>;

/// Forwarding state delta.
pub type FwDelta = (RouterId, Option<RouterId>, Option<RouterId>);

/// Mutable reference to tbe network that allows you to trigger a single event. You can either have
/// mutable access to the network exactly once by calling one of the functions implemented on
/// `NetworkRef`, or you can use `AsRef` to get a reference of `&Network<Q>` where you can access
/// all immutable methods.
#[derive(Debug)]
pub struct NetworkRef<'a, Q>(&'a mut Network<Q>);

impl<'a, Q> AsRef<Network<Q>> for NetworkRef<'a, Q> {
    fn as_ref(&self) -> &Network<Q> {
        self.0
    }
}

impl<'a, Q> NetworkRef<'a, Q>
where
    Q: EventQueue,
    Q::Priority: FmtPriority + Default + Clone,
{
    /// Wrapper around [`Network::set_bgp_session`]
    pub fn set_bgp_session(
        self,
        source: RouterId,
        target: RouterId,
        session_type: Option<BgpSessionType>,
    ) -> Result<(), NetworkError> {
        self.0.set_bgp_session(source, target, session_type)
    }

    /// Wrapper around [`Network::set_link_weight`]
    pub fn set_link_weight(
        self,
        source: RouterId,
        target: RouterId,
        weight: LinkWeight,
    ) -> Result<LinkWeight, NetworkError> {
        self.0.set_link_weight(source, target, weight)
    }

    /// Wrapper around [`Network::set_bgp_route_map`]
    pub fn set_bgp_route_map(
        self,
        router: RouterId,
        route_map: RouteMap,
        direction: RouteMapDirection,
    ) -> Result<Option<RouteMap>, NetworkError> {
        self.0.set_bgp_route_map(router, route_map, direction)
    }

    /// Wrapper around [`Network::remove_bgp_route_map`]
    pub fn remove_bgp_route_map(
        self,
        router: RouterId,
        order: usize,
        direction: RouteMapDirection,
    ) -> Result<Option<RouteMap>, NetworkError> {
        self.0.remove_bgp_route_map(router, order, direction)
    }

    /// Wrapper around [`Network::advertise_external_route`]
    pub fn advertise_external_route(
        self,
        source: RouterId,
        prefix: Prefix,
        as_path: Vec<AsId>,
        med: Option<u32>,
        community: Option<u32>,
    ) -> Result<(), NetworkError> {
        self.0
            .advertise_external_route(source, prefix, as_path, med, community)
    }

    /// Wrapper around [`Network::retract_external_route`]
    pub fn retract_external_route(
        self,
        source: RouterId,
        prefix: Prefix,
    ) -> Result<(), NetworkError> {
        self.0.retract_external_route(source, prefix)
    }

    /// Wrapper around [`Network::simulate_link_failure`]
    pub fn simulate_link_failure(
        self,
        router_a: RouterId,
        router_b: RouterId,
    ) -> Result<(), NetworkError> {
        self.0.simulate_link_failure(router_a, router_b)
    }
}

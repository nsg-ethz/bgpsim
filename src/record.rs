// NetSim: BGP Network Simulator written in Rust
// Copyright (C) 2022 Tibor Schneider
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

//! Module to record actions on the network and extract a trace of how the forwarding state changes
//! over time.

use std::collections::HashMap;

use crate::{
    event::EventQueue,
    event::FmtPriority,
    forwarding_state::ForwardingState,
    interactive::InteractiveNetwork,
    network::Network,
    types::{NetworkError, Prefix, RouterId},
};

/// Extension trait that allows you to record events on the network.
pub trait RecordNetwork<Q> {
    /// Simulate a single action on the network and extract the record of the convergence
    /// process. This function will record the forwarding state of all prefixes in the network.
    ///
    /// This function will return either the trace and the initial forwarding state, or the network
    /// error generated by `f`.
    fn record<F>(&mut self, f: F) -> Result<ConvergenceRecording, NetworkError>
    where
        F: FnOnce(&mut Network<Q>) -> Result<(), NetworkError>;

    /// Simulate the network (by running all enqueued events). During this, construct a
    /// `ConvergenceRecording` by recording every single change in the forwarding behavior of the
    /// network. This function takes `initial_fw_state` (before any event happened), and the
    /// `initial_trace`, that contains the difference from the initial forarding state to the state
    /// that is currently present.
    ///
    /// Consider the implementation of [`RecordNetwork::record`] for `Network` to see an example of
    /// how to use this function.
    fn record_prepared(
        &mut self,
        initial_fw_state: ForwardingState,
        initial_trace: HashMap<Prefix, ConvergenceTrace>,
    ) -> Result<ConvergenceRecording, NetworkError>;
}

impl<Q> RecordNetwork<Q> for Network<Q>
where
    Q: EventQueue,
    Q::Priority: FmtPriority + Default + Clone,
{
    fn record<F>(&mut self, f: F) -> Result<ConvergenceRecording, NetworkError>
    where
        F: FnOnce(&mut Network<Q>) -> Result<(), NetworkError>,
    {
        // set the queue to skip mode.
        let original_skip_value = self.skip_queue;
        self.skip_queue = true;

        // get the forwarding state before
        let fw_state_before = self.get_forwarding_state();

        // execute the function
        f(self)?;

        // get the forwarding state difference and start generating the trace
        let fw_state_after = self.get_forwarding_state();
        let diff = fw_state_before.diff(&fw_state_after);

        let trace = diff
            .into_iter()
            .map(|(prefix, delta)| (prefix, vec![delta]))
            .collect::<HashMap<Prefix, ConvergenceTrace>>();

        // now, generate the recording using the intrinsic function
        let record = self.record_prepared(fw_state_before, trace)?;

        // reset the queue skip property
        self.skip_queue = original_skip_value;

        Ok(record)
    }

    fn record_prepared(
        &mut self,
        initial_fw_state: ForwardingState,
        mut trace: HashMap<Prefix, ConvergenceTrace>,
    ) -> Result<ConvergenceRecording, NetworkError> {
        while let Some((step, event)) = self.simulate_step()? {
            if step.changed() {
                if let Some(prefix) = step.prefix {
                    trace.entry(prefix).or_default().push(vec![(
                        event.router(),
                        step.old,
                        step.new,
                    )]);
                }
            }
        }
        Ok(ConvergenceRecording::new(initial_fw_state, trace))
    }
}

/// Record of an entire convergence process that captures the history of each change in the
/// forwarding state of the network. This is a record that allows the state to be moved forwards or
/// backwards in time. The recording can be changed on a per-prefix level.
#[derive(Debug, Clone, PartialEq)]
pub struct ConvergenceRecording {
    state: ForwardingState,
    trace: HashMap<Prefix, ConvergenceTrace>,
    pointers: HashMap<Prefix, usize>,
}

impl ConvergenceRecording {
    /// Create a Recofrding from a trace and an initial forwarding state
    pub fn new(
        initial_fw_state: ForwardingState,
        trace: HashMap<Prefix, ConvergenceTrace>,
    ) -> Self {
        let pointers: HashMap<Prefix, usize> = trace.keys().map(|p| (*p, 0)).collect();
        ConvergenceRecording {
            state: initial_fw_state,
            trace,
            pointers,
        }
    }

    /// Get a reference to the current forwarding state
    pub fn state(&mut self) -> &mut ForwardingState {
        &mut self.state
    }

    /// Get a reference of the convergence trace.
    pub fn trace(&self) -> &HashMap<Prefix, ConvergenceTrace> {
        &self.trace
    }

    /// Transform the recording into a trace.
    pub fn as_trace(self) -> HashMap<Prefix, ConvergenceTrace> {
        self.trace
    }

    /// Perform a single step for an individual prefix. If the forwarding state is already in the
    /// final state for the specifiied prefix, then this function will return `None`. Otherwise, it
    /// will return a slice containing all deltas that were applied during this function call.
    pub fn step(&mut self, prefix: Prefix) -> Option<&[FwDelta]> {
        let pointer = self.pointers.get_mut(&prefix)?;
        let trace = self.trace.get(&prefix)?;
        if *pointer >= trace.len() {
            // already out of bounds
            return None;
        }
        // apply the delta at the current position
        let deltas = trace.get(*pointer)?;
        for (router, _, new_nh) in deltas {
            self.state.update(*router, prefix, new_nh.clone());
        }

        // increment the pointer
        *pointer += 1;

        // return the applied deltas
        Some(deltas)
    }

    /// Undo a single step for an individual prefix. If the forwarding state is already in the
    /// initial state for the specifiied prefix, then this function will return `None`. Otherwise, it
    /// will return a slice containing all deltas that applied *in reverse direction* during this
    /// function call.
    pub fn back(&mut self, prefix: Prefix) -> Option<&[FwDelta]> {
        let pointer = self.pointers.get_mut(&prefix)?;
        let trace = self.trace.get(&prefix)?;
        if *pointer == 0 {
            // already out of bounds
            return None;
        }
        // decrement the pointer
        *pointer -= 1;
        // apply the delta at the current position
        let deltas = trace.get(*pointer)?;
        for (router, old_nh, _) in deltas {
            self.state.update(*router, prefix, old_nh.clone());
        }

        // return the applied deltas
        Some(deltas)
    }

    /// Get the position of the recording for the given prefix.
    pub fn pos(&self, prefix: Prefix) -> usize {
        self.pointers.get(&prefix).copied().unwrap_or_default()
    }

    /// Get the length of the recording for the given prefix
    #[allow(clippy::len_without_is_empty)]
    pub fn len(&self, prefix: Prefix) -> usize {
        self.trace.get(&prefix).map(|t| t.len()).unwrap_or_default()
    }

    /// Check if the recording is empty for the given prefix
    pub fn is_empty(&self, prefix: Prefix) -> bool {
        self.trace
            .get(&prefix)
            .map(|t| t.is_empty())
            .unwrap_or(true)
    }
}

/// This structure captures the essence of a trace, that is, the entire evolution of the forwarding
/// state during the convergence process. It does not capture the initial or the final state, but it
/// should be efficient to compare entries.
pub type ConvergenceTrace = Vec<Vec<FwDelta>>;

/// Forwarding state delta.
pub type FwDelta = (RouterId, Vec<RouterId>, Vec<RouterId>);
